{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar RelayOperationTracker =\n/*#__PURE__*/\nfunction () {\n  function RelayOperationTracker() {\n    this._ownersToPendingOperations = new Map();\n    this._pendingOperationsToOwners = new Map();\n    this._ownersToPromise = new Map();\n  }\n  /**\n   * Update the map of current processing operations with the set of\n   * affected owners and notify subscribers\n   */\n\n\n  var _proto = RelayOperationTracker.prototype;\n\n  _proto.update = function update(pendingOperation, affectedOwners) {\n    if (affectedOwners.size === 0) {\n      return;\n    }\n\n    var newlyAffectedOwners = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = affectedOwners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var owner = _step.value;\n\n        var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(owner);\n\n        if (pendingOperationsAffectingOwner != null) {\n          // In this case the `owner` already affected by some operations\n          // We just need to detect, is it the same operation that we already\n          // have in the list, or it's a new operation\n          if (!pendingOperationsAffectingOwner.has(pendingOperation)) {\n            pendingOperationsAffectingOwner.add(pendingOperation);\n            newlyAffectedOwners.add(owner);\n          }\n        } else {\n          // This is a new `owner` that is affected by the operation\n          this._ownersToPendingOperations.set(owner, new Set([pendingOperation]));\n\n          newlyAffectedOwners.add(owner);\n        }\n      } // No new owners were affected by this operation, we may stop here\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (newlyAffectedOwners.size === 0) {\n      return;\n    } // But, if some owners were affected we need to add them to\n    // the `_pendingOperationsToOwners` set\n\n\n    var ownersAffectedByOperation = this._pendingOperationsToOwners.get(pendingOperation) || new Set();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = newlyAffectedOwners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _owner = _step2.value;\n\n        this._resolveOwnerResolvers(_owner);\n\n        ownersAffectedByOperation.add(_owner);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    this._pendingOperationsToOwners.set(pendingOperation, ownersAffectedByOperation);\n  }\n  /**\n   * Once pending operation is completed we need to remove it\n   * from all tracking maps\n   */\n  ;\n\n  _proto.complete = function complete(pendingOperation) {\n    var affectedOwners = this._pendingOperationsToOwners.get(pendingOperation);\n\n    if (affectedOwners == null) {\n      return;\n    } // These were the owners affected only by `pendingOperation`\n\n\n    var completedOwners = new Set(); // These were the owners affected by `pendingOperation`\n    // and some other operations\n\n    var updatedOwners = new Set();\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = affectedOwners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var owner = _step3.value;\n\n        var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(owner);\n\n        if (!pendingOperationsAffectingOwner) {\n          continue;\n        }\n\n        pendingOperationsAffectingOwner[\"delete\"](pendingOperation);\n\n        if (pendingOperationsAffectingOwner.size > 0) {\n          updatedOwners.add(owner);\n        } else {\n          completedOwners.add(owner);\n        }\n      } // Complete subscriptions for all owners, affected by `pendingOperation`\n\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n          _iterator3[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = completedOwners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _owner2 = _step4.value;\n\n        this._resolveOwnerResolvers(_owner2);\n\n        this._ownersToPendingOperations[\"delete\"](_owner2);\n      } // Update all owner that were updated by `pendingOperation` but still\n      // are affected by other operations\n\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n          _iterator4[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = updatedOwners[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var _owner3 = _step5.value;\n\n        this._resolveOwnerResolvers(_owner3);\n      } // Finally, remove pending operation\n\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n          _iterator5[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    this._pendingOperationsToOwners[\"delete\"](pendingOperation);\n  };\n\n  _proto._resolveOwnerResolvers = function _resolveOwnerResolvers(owner) {\n    var promiseEntry = this._ownersToPromise.get(owner);\n\n    if (promiseEntry != null) {\n      promiseEntry.resolve();\n    }\n\n    this._ownersToPromise[\"delete\"](owner);\n  };\n\n  _proto.getPromiseForPendingOperationsAffectingOwner = function getPromiseForPendingOperationsAffectingOwner(owner) {\n    if (!this._ownersToPendingOperations.has(owner)) {\n      return null;\n    }\n\n    var cachedPromiseEntry = this._ownersToPromise.get(owner);\n\n    if (cachedPromiseEntry != null) {\n      return cachedPromiseEntry.promise;\n    }\n\n    var resolve;\n    var promise = new Promise(function (r) {\n      resolve = r;\n    });\n    !(resolve != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayOperationTracker: Expected resolver to be defined. If you' + 'are seeing this, it is likely a bug in Relay.') : invariant(false) : void 0;\n\n    this._ownersToPromise.set(owner, {\n      promise: promise,\n      resolve: resolve\n    });\n\n    return promise;\n  };\n\n  return RelayOperationTracker;\n}();\n\nmodule.exports = RelayOperationTracker;","map":{"version":3,"sources":["/Users/xindi/xindi/relay-tutorial/node_modules/relay-runtime/lib/store/RelayOperationTracker.js"],"names":["invariant","require","RelayOperationTracker","_ownersToPendingOperations","Map","_pendingOperationsToOwners","_ownersToPromise","_proto","prototype","update","pendingOperation","affectedOwners","size","newlyAffectedOwners","Set","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","owner","value","pendingOperationsAffectingOwner","get","has","add","set","err","ownersAffectedByOperation","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_owner","_resolveOwnerResolvers","complete","completedOwners","updatedOwners","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_owner2","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","_owner3","promiseEntry","resolve","getPromiseForPendingOperationsAffectingOwner","cachedPromiseEntry","promise","Promise","r","process","env","NODE_ENV","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar RelayOperationTracker =\n/*#__PURE__*/\nfunction () {\n  function RelayOperationTracker() {\n    this._ownersToPendingOperations = new Map();\n    this._pendingOperationsToOwners = new Map();\n    this._ownersToPromise = new Map();\n  }\n  /**\n   * Update the map of current processing operations with the set of\n   * affected owners and notify subscribers\n   */\n\n\n  var _proto = RelayOperationTracker.prototype;\n\n  _proto.update = function update(pendingOperation, affectedOwners) {\n    if (affectedOwners.size === 0) {\n      return;\n    }\n\n    var newlyAffectedOwners = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = affectedOwners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var owner = _step.value;\n\n        var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(owner);\n\n        if (pendingOperationsAffectingOwner != null) {\n          // In this case the `owner` already affected by some operations\n          // We just need to detect, is it the same operation that we already\n          // have in the list, or it's a new operation\n          if (!pendingOperationsAffectingOwner.has(pendingOperation)) {\n            pendingOperationsAffectingOwner.add(pendingOperation);\n            newlyAffectedOwners.add(owner);\n          }\n        } else {\n          // This is a new `owner` that is affected by the operation\n          this._ownersToPendingOperations.set(owner, new Set([pendingOperation]));\n\n          newlyAffectedOwners.add(owner);\n        }\n      } // No new owners were affected by this operation, we may stop here\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (newlyAffectedOwners.size === 0) {\n      return;\n    } // But, if some owners were affected we need to add them to\n    // the `_pendingOperationsToOwners` set\n\n\n    var ownersAffectedByOperation = this._pendingOperationsToOwners.get(pendingOperation) || new Set();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = newlyAffectedOwners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _owner = _step2.value;\n\n        this._resolveOwnerResolvers(_owner);\n\n        ownersAffectedByOperation.add(_owner);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    this._pendingOperationsToOwners.set(pendingOperation, ownersAffectedByOperation);\n  }\n  /**\n   * Once pending operation is completed we need to remove it\n   * from all tracking maps\n   */\n  ;\n\n  _proto.complete = function complete(pendingOperation) {\n    var affectedOwners = this._pendingOperationsToOwners.get(pendingOperation);\n\n    if (affectedOwners == null) {\n      return;\n    } // These were the owners affected only by `pendingOperation`\n\n\n    var completedOwners = new Set(); // These were the owners affected by `pendingOperation`\n    // and some other operations\n\n    var updatedOwners = new Set();\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = affectedOwners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var owner = _step3.value;\n\n        var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(owner);\n\n        if (!pendingOperationsAffectingOwner) {\n          continue;\n        }\n\n        pendingOperationsAffectingOwner[\"delete\"](pendingOperation);\n\n        if (pendingOperationsAffectingOwner.size > 0) {\n          updatedOwners.add(owner);\n        } else {\n          completedOwners.add(owner);\n        }\n      } // Complete subscriptions for all owners, affected by `pendingOperation`\n\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n          _iterator3[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = completedOwners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _owner2 = _step4.value;\n\n        this._resolveOwnerResolvers(_owner2);\n\n        this._ownersToPendingOperations[\"delete\"](_owner2);\n      } // Update all owner that were updated by `pendingOperation` but still\n      // are affected by other operations\n\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n          _iterator4[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = updatedOwners[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var _owner3 = _step5.value;\n\n        this._resolveOwnerResolvers(_owner3);\n      } // Finally, remove pending operation\n\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n          _iterator5[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    this._pendingOperationsToOwners[\"delete\"](pendingOperation);\n  };\n\n  _proto._resolveOwnerResolvers = function _resolveOwnerResolvers(owner) {\n    var promiseEntry = this._ownersToPromise.get(owner);\n\n    if (promiseEntry != null) {\n      promiseEntry.resolve();\n    }\n\n    this._ownersToPromise[\"delete\"](owner);\n  };\n\n  _proto.getPromiseForPendingOperationsAffectingOwner = function getPromiseForPendingOperationsAffectingOwner(owner) {\n    if (!this._ownersToPendingOperations.has(owner)) {\n      return null;\n    }\n\n    var cachedPromiseEntry = this._ownersToPromise.get(owner);\n\n    if (cachedPromiseEntry != null) {\n      return cachedPromiseEntry.promise;\n    }\n\n    var resolve;\n    var promise = new Promise(function (r) {\n      resolve = r;\n    });\n    !(resolve != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayOperationTracker: Expected resolver to be defined. If you' + 'are seeing this, it is likely a bug in Relay.') : invariant(false) : void 0;\n\n    this._ownersToPromise.set(owner, {\n      promise: promise,\n      resolve: resolve\n    });\n\n    return promise;\n  };\n\n  return RelayOperationTracker;\n}();\n\nmodule.exports = RelayOperationTracker;"]},"metadata":{},"sourceType":"script"}