{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar stableCopy = require('../util/stableCopy');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require2.createNormalizationSelector;\n\nvar _require3 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require3.ROOT_TYPE,\n    TYPENAME_KEY = _require3.TYPENAME_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor =\n/*#__PURE__*/\nfunction () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        optimisticConfig = _ref.optimisticConfig,\n        publishQueue = _ref.publishQueue,\n        scheduler = _ref.scheduler,\n        sink = _ref.sink,\n        source = _ref.source,\n        store = _ref.store,\n        updater = _ref.updater,\n        operationTracker = _ref.operationTracker,\n        getDataID = _ref.getDataID,\n        isClientPayload = _ref.isClientPayload;\n    this._getDataID = getDataID;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._publishQueue = publishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._store = store;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        return _this._start(id, subscription);\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._publishQueue.revertUpdate(update);\n      });\n\n      this._publishQueue.run();\n    }\n\n    this._incrementalResults.clear();\n\n    this._completeOperationTracker();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      _this4._handleNext(response);\n\n      _this4._maybeCompleteSubscriptionOperationTracking();\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this; // Once thing to notice here: if one of the responses in array has errors\n    // All batch will be ignored.\n\n\n    return responses.map(function (response) {\n      if (response.data == null) {\n        var messages = response.errors ? response.errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: response.errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        };\n        throw error;\n      }\n\n      var responseWithData = response;\n      return responseWithData;\n    });\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    var responsesWithData = this._handleErrorResponse(Array.isArray(response) ? response : [response]); // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1]; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at-most one non-incremental payload\n    //  * followed zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // w the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n\n    if (nonIncrementalResponses.length > 0) {\n      var payloadFollowups = this._processResponses(nonIncrementalResponses); // Please note, that we're passing `this._operation` to the publish\n      // queue here, which will later passed to the store (via notify)\n      // to indicate that this is an operation that cause the store to update\n\n\n      var updatedOwners = this._publishQueue.run(this._operation);\n\n      this._updateOperationTracker(updatedOwners);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses); // For the incremental case, we're only handling follow-up responses\n      // for already initiated operation (and we're not passing it to\n      // the run(...) call)\n\n\n      var _updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(_updatedOwners);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        getDataID: this._getDataID,\n        path: [],\n        request: this._operation.request\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          moduleImportPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._publishQueue.applyUpdate(update);\n    });\n\n    this._publishQueue.run();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {\n      var moduleImportPayloads = payload.moduleImportPayloads;\n      var operationLoader = this._operationLoader;\n      !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = moduleImportPayloads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var moduleImportPayload = _step.value;\n          var operation = operationLoader.get(moduleImportPayload.operationReference);\n\n          if (operation == null) {\n            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);\n          } else {\n            var moduleImportOptimisitcUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);\n\n            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {\n    var selector = createNormalizationSelector(operation, moduleImportPayload.dataID, moduleImportPayload.variables);\n    return normalizeResponse({\n      data: moduleImportPayload.data\n    }, selector, moduleImportPayload.typeName, {\n      getDataID: this._getDataID,\n      path: moduleImportPayload.path,\n      request: this._operation.request\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(operation, moduleImportPayload) {\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {\n    var _this7 = this;\n\n    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisitcUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisitcUpdates.forEach(function (update) {\n        return _this7._publishQueue.applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayModernQueryExecutor: Unexpected ModuleImport optimisitc ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n\n        _this7._publishQueue.run();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        return _this8._publishQueue.revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        getDataID: _this8._getDataID,\n        path: [],\n        request: _this8._operation.request\n      });\n\n      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          moduleImportPayloads = payload.moduleImportPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {\n        var operationLoader = _this9._operationLoader;\n        !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n        moduleImportPayloads.forEach(function (moduleImportPayload) {\n          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            var updatedOwners = _this9._publishQueue.run();\n\n            _this9._updateOperationTracker(updatedOwners);\n\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    var isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n\n    if (!isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {\n    var _this10 = this;\n\n    var syncOperation = operationLoader.get(moduleImportPayload.operationReference);\n\n    if (syncOperation != null) {\n      // If the operation module is available synchronously, normalize the\n      // data synchronously.\n      this._schedule(function () {\n        _this10._handleModuleImportPayload(moduleImportPayload, syncOperation);\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      });\n    } else {\n      // Otherwise load the operation module and schedule a task to normalize\n      // the data when the module is available.\n      var _id3 = this._nextSubscriptionId++;\n\n      this._pendingModulePayloadsCount++;\n\n      var decrementPendingCount = function decrementPendingCount() {\n        _this10._pendingModulePayloadsCount--;\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n      // errors thrown by the load function, which is user-defined. Guard\n      // against that with Observable.from(new Promise(<work>)).\n\n\n      RelayObservable.from(new Promise(function (resolve, reject) {\n        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);\n      })).map(function (operation) {\n        if (operation != null) {\n          _this10._schedule(function () {\n            _this10._handleModuleImportPayload(moduleImportPayload, operation);\n          });\n        }\n      }).subscribe({\n        complete: function complete() {\n          _this10._complete(_id3);\n\n          decrementPendingCount();\n        },\n        error: function error(_error4) {\n          _this10._error(_error4);\n\n          decrementPendingCount();\n        },\n        start: function start(subscription) {\n          return _this10._start(_id3, subscription);\n        }\n      });\n    }\n  };\n\n  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {\n    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    this._publishQueue.commitPayload(this._operation, relayPayload);\n\n    var updatedOwners = this._publishQueue.run();\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _this11 = this;\n\n    var _relayPayload$fieldPa; // Update the label => path => placeholder map\n\n\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      this._schedule(function () {\n        var payloadFollowups = _this11._processIncrementalResponses(pendingResponses);\n\n        var updatedOwners = _this11._publishQueue.run();\n\n        _this11._updateOperationTracker(updatedOwners);\n\n        _this11._processPayloadFollowups(payloadFollowups);\n      });\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this12 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this12._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this12._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this12._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this12._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var parentID = placeholder.selector.dataID;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      request: this._operation.request\n    });\n\n    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      request: this._operation.request\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (this._operationTracker != null && updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    if (this._operationTracker != null) {\n      this._operationTracker.complete(this._operation.request);\n    }\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])({}, relayPayload, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};","map":{"version":3,"sources":["/Users/xindi/xindi/graphql-relay-blog/frontend/node_modules/relay-runtime/lib/store/RelayModernQueryExecutor.js"],"names":["_interopRequireDefault","require","_objectSpread2","_toConsumableArray2","RelayError","RelayModernRecord","RelayObservable","RelayRecordSource","RelayResponseNormalizer","invariant","stableCopy","warning","_require","generateClientID","_require2","createNormalizationSelector","_require3","ROOT_TYPE","TYPENAME_KEY","getStorageKey","execute","config","Executor","_ref","_this","operation","operationExecutions","operationLoader","optimisticConfig","publishQueue","scheduler","sink","source","store","updater","operationTracker","getDataID","isClientPayload","_getDataID","_incrementalPayloadsPending","_incrementalResults","Map","_nextSubscriptionId","_operation","_operationExecutions","_operationLoader","_operationTracker","_operationUpdateEpochs","_optimisticUpdates","_pendingModulePayloadsCount","_publishQueue","_scheduler","_sink","_source","_state","_store","_subscriptions","_updater","_isClientPayload","id","subscribe","complete","_complete","error","_error2","_error","next","response","_next","start","subscription","_start","_processOptimisticResponse","data","_proto","prototype","cancel","_this2","request","identifier","size","forEach","sub","unsubscribe","clear","optimisticUpdates","update","revertUpdate","run","_completeOperationTracker","_updateActiveState","activeState","process","env","NODE_ENV","set","_schedule","task","_this3","_id2","create","cancellationToken","schedule","_error3","_id","_this4","_handleNext","_maybeCompleteSubscriptionOperationTracking","_handleErrorResponse","responses","_this5","map","messages","errors","_ref2","message","join","node","params","name","variables","responseWithData","_handleOptimisticResponses","_response$extensions","length","some","responsePart","_responsePart$extensi","extensions","isOptimistic","responsesWithData","Array","isArray","_partitionGraphQLResp","partitionGraphQLResponses","nonIncrementalResponses","incrementalResponses","payloadFollowups","_processResponses","updatedOwners","_updateOperationTracker","_processPayloadFollowups","_payloadFollowups","_processIncrementalResponses","_updatedOwners","_this6","payload","normalizeResponse","root","path","validateOptimisticResponsePayload","push","_processOptimisticFollowups","fieldPayloads","incrementalPlaceholders","moduleImportPayloads","isFinal","applyUpdate","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","done","moduleImportPayload","value","get","operationReference","_processAsyncOptimisticModuleImport","moduleImportOptimisitcUpdates","_processOptimisticModuleImport","apply","err","_normalizeModuleImport","selector","dataID","typeName","modulePayload","_this7","load","then","_this$_optimisticUpda","_this8","payloadPart","relayPayload","commitPayload","payloads","_this9","_processModuleImportPayload","incrementalPlaceholder","_processIncrementalPlaceholder","relayPayloads","placeholder","kind","_processDeferResponse","label","isSubscriptionOperation","operationKind","_this10","syncOperation","_handleModuleImportPayload","_id3","decrementPendingCount","from","Promise","resolve","reject","_error4","_this11","_relayPayload$fieldPa","pathKey","String","resultForLabel","resultForPath","pendingResponses","parentID","parentRecord","parentPayloads","filter","fieldPayload","fieldID","fieldKey","nextParentRecord","nextParentPayloads","previousParentEntry","record","handlePayloads","dedupePayload","key","stableStringify","values","_this12","incrementalResponse","indexOf","_pathKey","slice","_resultForPath","_placeholder","_processStreamResponse","parentEntry","_response$extensions2","handleFieldsRelayPayload","is_final","field","selections","plural","_this$_normalizeStrea","_normalizeStreamItem","itemID","itemIndex","prevIDs","storageKey","currentParentRecord","currentItems","getLinkedRecords","currentItem","index","nextItems","setLinkedRecords","normalizationPath","_field$alias","_field$concreteType","_this$_getDataID","responseKey","alias","getLinkedRecordIDs","finalPathEntry","parseInt","concreteType","clone","nextIDs","setLinkedRecordIDs","concat","Set","options","_response$extensions3","normalize","_JSON$stringify","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar stableCopy = require('../util/stableCopy');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require2.createNormalizationSelector;\n\nvar _require3 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require3.ROOT_TYPE,\n    TYPENAME_KEY = _require3.TYPENAME_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor =\n/*#__PURE__*/\nfunction () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        optimisticConfig = _ref.optimisticConfig,\n        publishQueue = _ref.publishQueue,\n        scheduler = _ref.scheduler,\n        sink = _ref.sink,\n        source = _ref.source,\n        store = _ref.store,\n        updater = _ref.updater,\n        operationTracker = _ref.operationTracker,\n        getDataID = _ref.getDataID,\n        isClientPayload = _ref.isClientPayload;\n    this._getDataID = getDataID;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._publishQueue = publishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._store = store;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        return _this._start(id, subscription);\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._publishQueue.revertUpdate(update);\n      });\n\n      this._publishQueue.run();\n    }\n\n    this._incrementalResults.clear();\n\n    this._completeOperationTracker();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      _this4._handleNext(response);\n\n      _this4._maybeCompleteSubscriptionOperationTracking();\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    // Once thing to notice here: if one of the responses in array has errors\n    // All batch will be ignored.\n    return responses.map(function (response) {\n      if (response.data == null) {\n        var messages = response.errors ? response.errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: response.errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        };\n        throw error;\n      }\n\n      var responseWithData = response;\n      return responseWithData;\n    });\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    var responsesWithData = this._handleErrorResponse(Array.isArray(response) ? response : [response]); // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1]; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at-most one non-incremental payload\n    //  * followed zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // w the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n\n    if (nonIncrementalResponses.length > 0) {\n      var payloadFollowups = this._processResponses(nonIncrementalResponses); // Please note, that we're passing `this._operation` to the publish\n      // queue here, which will later passed to the store (via notify)\n      // to indicate that this is an operation that cause the store to update\n\n\n      var updatedOwners = this._publishQueue.run(this._operation);\n\n      this._updateOperationTracker(updatedOwners);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses); // For the incremental case, we're only handling follow-up responses\n      // for already initiated operation (and we're not passing it to\n      // the run(...) call)\n\n\n      var _updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(_updatedOwners);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        getDataID: this._getDataID,\n        path: [],\n        request: this._operation.request\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          moduleImportPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._publishQueue.applyUpdate(update);\n    });\n\n    this._publishQueue.run();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {\n      var moduleImportPayloads = payload.moduleImportPayloads;\n      var operationLoader = this._operationLoader;\n      !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = moduleImportPayloads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var moduleImportPayload = _step.value;\n          var operation = operationLoader.get(moduleImportPayload.operationReference);\n\n          if (operation == null) {\n            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);\n          } else {\n            var moduleImportOptimisitcUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);\n\n            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {\n    var selector = createNormalizationSelector(operation, moduleImportPayload.dataID, moduleImportPayload.variables);\n    return normalizeResponse({\n      data: moduleImportPayload.data\n    }, selector, moduleImportPayload.typeName, {\n      getDataID: this._getDataID,\n      path: moduleImportPayload.path,\n      request: this._operation.request\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(operation, moduleImportPayload) {\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {\n    var _this7 = this;\n\n    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisitcUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisitcUpdates.forEach(function (update) {\n        return _this7._publishQueue.applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayModernQueryExecutor: Unexpected ModuleImport optimisitc ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n\n        _this7._publishQueue.run();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        return _this8._publishQueue.revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        getDataID: _this8._getDataID,\n        path: [],\n        request: _this8._operation.request\n      });\n\n      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          moduleImportPayloads = payload.moduleImportPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {\n        var operationLoader = _this9._operationLoader;\n        !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n        moduleImportPayloads.forEach(function (moduleImportPayload) {\n          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            var updatedOwners = _this9._publishQueue.run();\n\n            _this9._updateOperationTracker(updatedOwners);\n\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    var isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n\n    if (!isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {\n    var _this10 = this;\n\n    var syncOperation = operationLoader.get(moduleImportPayload.operationReference);\n\n    if (syncOperation != null) {\n      // If the operation module is available synchronously, normalize the\n      // data synchronously.\n      this._schedule(function () {\n        _this10._handleModuleImportPayload(moduleImportPayload, syncOperation);\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      });\n    } else {\n      // Otherwise load the operation module and schedule a task to normalize\n      // the data when the module is available.\n      var _id3 = this._nextSubscriptionId++;\n\n      this._pendingModulePayloadsCount++;\n\n      var decrementPendingCount = function decrementPendingCount() {\n        _this10._pendingModulePayloadsCount--;\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n      // errors thrown by the load function, which is user-defined. Guard\n      // against that with Observable.from(new Promise(<work>)).\n\n\n      RelayObservable.from(new Promise(function (resolve, reject) {\n        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);\n      })).map(function (operation) {\n        if (operation != null) {\n          _this10._schedule(function () {\n            _this10._handleModuleImportPayload(moduleImportPayload, operation);\n          });\n        }\n      }).subscribe({\n        complete: function complete() {\n          _this10._complete(_id3);\n\n          decrementPendingCount();\n        },\n        error: function error(_error4) {\n          _this10._error(_error4);\n\n          decrementPendingCount();\n        },\n        start: function start(subscription) {\n          return _this10._start(_id3, subscription);\n        }\n      });\n    }\n  };\n\n  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {\n    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    this._publishQueue.commitPayload(this._operation, relayPayload);\n\n    var updatedOwners = this._publishQueue.run();\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _this11 = this;\n\n    var _relayPayload$fieldPa;\n\n    // Update the label => path => placeholder map\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      this._schedule(function () {\n        var payloadFollowups = _this11._processIncrementalResponses(pendingResponses);\n\n        var updatedOwners = _this11._publishQueue.run();\n\n        _this11._updateOperationTracker(updatedOwners);\n\n        _this11._processPayloadFollowups(payloadFollowups);\n      });\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this12 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this12._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this12._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this12._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this12._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var parentID = placeholder.selector.dataID;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      request: this._operation.request\n    });\n\n    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      request: this._operation.request\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (this._operationTracker != null && updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    if (this._operationTracker != null) {\n      this._operationTracker.complete(this._operation.request);\n    }\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])({}, relayPayload, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};"]},"metadata":{},"sourceType":"script"}