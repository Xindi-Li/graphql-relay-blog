{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayStoreUtils'),\n    ROOT_ID = _require.ROOT_ID,\n    ROOT_TYPE = _require.ROOT_TYPE;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 0;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore =\n/*#__PURE__*/\nfunction () {\n  function RelayModernStore(source, options) {\n    var _ref, _ref2, _ref3, _ref4; // Prevent mutation of a record from outside the store.\n\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_ref = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _ref !== void 0 ? _ref : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcScheduler = (_ref2 = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _ref2 !== void 0 ? _ref2 : resolveImmediate;\n    this._getDataID = (_ref3 = options === null || options === void 0 ? void 0 : options.UNSTABLE_DO_NOT_USE_getDataID) !== null && _ref3 !== void 0 ? _ref3 : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._hasScheduledGC = false;\n    this._index = 0;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this._operationLoader = (_ref4 = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _ref4 !== void 0 ? _ref4 : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._subscriptions = new Set();\n    this._updatedRecordIDs = {};\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _this$_optimisticSour2, _ref5, _ref6;\n\n    var selector = operation.root;\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occured.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation ocurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        //  (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var target = (_ref5 = options === null || options === void 0 ? void 0 : options.target) !== null && _ref5 !== void 0 ? _ref5 : source;\n    var handlers = (_ref6 = options === null || options === void 0 ? void 0 : options.handlers) !== null && _ref6 !== void 0 ? _ref6 : [];\n    var operationAvailability = DataChecker.check(source, target, selector, handlers, this._operationLoader, this._getDataID);\n    return getAvailablityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this = this;\n\n    var id = operation.request.identifier;\n\n    var dispose = function dispose() {\n      // When disposing, instead of immediately decrementing the refCount and\n      // potentially deleting/collecting the root, move the operation onto\n      // the release buffer. When the operation is extracted from the release\n      // buffer, we will determine if it needs to be collected.\n      _this._releaseBuffer.push(id); // Only when the release buffer is full do we actually:\n      // - extract the least recent operation in the release buffer\n      // - attempt to release it and run GC if it's no longer referenced\n      //   (refCount reached 0).\n\n\n      if (_this._releaseBuffer.length > _this._gcReleaseBufferSize) {\n        var _id = _this._releaseBuffer.shift();\n\n        var _rootEntry = _this._roots.get(_id);\n\n        if (_rootEntry == null) {\n          // If operation has already been fully released, we don't need\n          // to do anything.\n          return;\n        }\n\n        if (_rootEntry.refCount > 0) {\n          // If the operation is still retained by other callers\n          // decrement the refCount\n          _rootEntry.refCount -= 1;\n        } else {\n          // Otherwise fully release the query and run GC.\n          _this._roots[\"delete\"](_id);\n\n          _this._scheduleGC();\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      // If we've previously retained this operation, inrement the refCount\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 0,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners form the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this2 = this; // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this2._updateSubscription(source, subscription);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this2._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    this._updatedRecordIDs = {};\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        var _rootEntry$fetchTime;\n\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = (_rootEntry$fetchTime = rootEntry.fetchTime) !== null && _rootEntry$fetchTime !== void 0 ? _rootEntry$fetchTime : Date.now();\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs);\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this3 = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this3._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4._scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  } // Returns the owner (RequestDescriptor) if the subscription was affected by the\n  // latest update, or null if it was not affected.\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasOverlappingIDs(snapshot.seenRecords, this._updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = prevInvalidationState.dataIDs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    var _this8 = this;\n\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value than\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(_this8.getSource(), snapshot.selector);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    this._optimisticSource = null;\n\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto._scheduleGC = function _scheduleGC() {\n    var _this9 = this;\n\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._hasScheduledGC) {\n      return;\n    }\n\n    this._hasScheduledGC = true;\n\n    this._gcScheduler(function () {\n      _this9.__gc();\n\n      _this9._hasScheduledGC = false;\n    });\n  };\n\n  _proto.__gc = function __gc() {\n    var _this10 = this; // Don't run GC while there are optimistic updates applied\n\n\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var references = new Set(); // Mark all records that are traversable from a root\n\n    this._roots.forEach(function (_ref7) {\n      var operation = _ref7.operation;\n      var selector = operation.root;\n      RelayReferenceMarker.mark(_this10._recordSource, selector, references, _this10._operationLoader);\n    });\n\n    if (references.size === 0) {\n      // Short-circuit if *nothing* is referenced\n      this._recordSource.clear();\n    } else {\n      // Evict any unreferenced nodes\n      var storeIDs = this._recordSource.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var dataID = storeIDs[ii];\n\n        if (!references.has(dataID)) {\n          this._recordSource.remove(dataID);\n        }\n      }\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will marc records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs[dataID] = true;\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs[dataID] = true;\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs[dataID] = true;\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availablity of a an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailablityStatus(opearionAvailability, operationLastWrittenAt, operationFetchTime) {\n  var _operationFetchTime;\n\n  var mostRecentlyInvalidatedAt = opearionAvailability.mostRecentlyInvalidatedAt,\n      status = opearionAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return status === 'missing' ? {\n    status: 'missing'\n  } : {\n    status: 'available',\n    fetchTime: (_operationFetchTime = operationFetchTime) !== null && _operationFetchTime !== void 0 ? _operationFetchTime : null\n  };\n}\n\nRelayProfiler.instrumentMethods(RelayModernStore.prototype, {\n  lookup: 'RelayModernStore.prototype.lookup',\n  notify: 'RelayModernStore.prototype.notify',\n  publish: 'RelayModernStore.prototype.publish',\n  __gc: 'RelayModernStore.prototype.__gc'\n});\nmodule.exports = RelayModernStore;","map":{"version":3,"sources":["/Users/xindi/xindi/relay-tutorial/node_modules/relay-runtime/lib/store/RelayModernStore.js"],"names":["DataChecker","require","RelayModernRecord","RelayOptimisticRecordSource","RelayProfiler","RelayReader","RelayReferenceMarker","RelayStoreUtils","deepFreeze","defaultGetDataID","hasOverlappingIDs","invariant","recycleNodesInto","resolveImmediate","_require","ROOT_ID","ROOT_TYPE","DEFAULT_RELEASE_BUFFER_SIZE","RelayModernStore","source","options","_ref","_ref2","_ref3","_ref4","process","env","NODE_ENV","storeIDs","getRecordIDs","ii","length","record","get","freeze","_currentWriteEpoch","_gcHoldCounter","_gcReleaseBufferSize","gcReleaseBufferSize","_gcScheduler","gcScheduler","_getDataID","UNSTABLE_DO_NOT_USE_getDataID","_globalInvalidationEpoch","_hasScheduledGC","_index","_invalidationSubscriptions","Set","_invalidatedRecordIDs","_operationLoader","operationLoader","_optimisticSource","_recordSource","_releaseBuffer","_roots","Map","_shouldScheduleGC","_subscriptions","_updatedRecordIDs","initializeRecordSource","_proto","prototype","getSource","_this$_optimisticSour","check","operation","_this$_optimisticSour2","_ref5","_ref6","selector","root","globalInvalidationEpoch","rootEntry","request","identifier","operationLastWrittenAt","epoch","status","target","handlers","operationAvailability","getAvailablityStatus","fetchTime","retain","_this","id","dispose","push","_id","shift","_rootEntry","refCount","_scheduleGC","set","lookup","snapshot","read","notify","sourceOperation","invalidateStore","_this2","updatedOwners","forEach","subscription","owner","_updateSubscription","_updateInvalidationSubscription","clear","_rootEntry$fetchTime","Date","now","publish","idsMarkedForInvalidation","_this$_optimisticSour3","updateTargetFromSource","subscribe","callback","_this3","backup","stale","add","holdGC","_this4","toJSON","__getUpdatedRecordIDs","hasOverlappingUpdates","seenRecords","nextSnapshot","nextData","data","isMissingData","lookupInvalidationState","dataIDs","_this5","invalidations","dataID","_RelayModernRecord$ge","getInvalidationEpoch","checkInvalidationState","prevInvalidationState","latestInvalidationState","currentInvalidations","prevInvalidations","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","value","err","subscribeToInvalidationState","invalidationState","_this6","invalidatedStore","_this7","isSubscribedToInvalidatedIDs","some","has","_this8","create","restore","_this9","__gc","_this10","references","_ref7","mark","size","remove","rootRecord","currentWriteEpoch","updatedRecordIDs","invalidatedRecordIDs","targetRecord","sourceRecord","nextRecord","clone","setValue","INVALIDATED_AT_KEY","update","opearionAvailability","operationFetchTime","_operationFetchTime","mostRecentlyInvalidatedAt","instrumentMethods","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayStoreUtils'),\n    ROOT_ID = _require.ROOT_ID,\n    ROOT_TYPE = _require.ROOT_TYPE;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 0;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore =\n/*#__PURE__*/\nfunction () {\n  function RelayModernStore(source, options) {\n    var _ref, _ref2, _ref3, _ref4;\n\n    // Prevent mutation of a record from outside the store.\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_ref = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _ref !== void 0 ? _ref : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcScheduler = (_ref2 = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _ref2 !== void 0 ? _ref2 : resolveImmediate;\n    this._getDataID = (_ref3 = options === null || options === void 0 ? void 0 : options.UNSTABLE_DO_NOT_USE_getDataID) !== null && _ref3 !== void 0 ? _ref3 : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._hasScheduledGC = false;\n    this._index = 0;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this._operationLoader = (_ref4 = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _ref4 !== void 0 ? _ref4 : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._subscriptions = new Set();\n    this._updatedRecordIDs = {};\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _this$_optimisticSour2, _ref5, _ref6;\n\n    var selector = operation.root;\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occured.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation ocurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        //  (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var target = (_ref5 = options === null || options === void 0 ? void 0 : options.target) !== null && _ref5 !== void 0 ? _ref5 : source;\n    var handlers = (_ref6 = options === null || options === void 0 ? void 0 : options.handlers) !== null && _ref6 !== void 0 ? _ref6 : [];\n    var operationAvailability = DataChecker.check(source, target, selector, handlers, this._operationLoader, this._getDataID);\n    return getAvailablityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this = this;\n\n    var id = operation.request.identifier;\n\n    var dispose = function dispose() {\n      // When disposing, instead of immediately decrementing the refCount and\n      // potentially deleting/collecting the root, move the operation onto\n      // the release buffer. When the operation is extracted from the release\n      // buffer, we will determine if it needs to be collected.\n      _this._releaseBuffer.push(id); // Only when the release buffer is full do we actually:\n      // - extract the least recent operation in the release buffer\n      // - attempt to release it and run GC if it's no longer referenced\n      //   (refCount reached 0).\n\n\n      if (_this._releaseBuffer.length > _this._gcReleaseBufferSize) {\n        var _id = _this._releaseBuffer.shift();\n\n        var _rootEntry = _this._roots.get(_id);\n\n        if (_rootEntry == null) {\n          // If operation has already been fully released, we don't need\n          // to do anything.\n          return;\n        }\n\n        if (_rootEntry.refCount > 0) {\n          // If the operation is still retained by other callers\n          // decrement the refCount\n          _rootEntry.refCount -= 1;\n        } else {\n          // Otherwise fully release the query and run GC.\n          _this._roots[\"delete\"](_id);\n\n          _this._scheduleGC();\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      // If we've previously retained this operation, inrement the refCount\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 0,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners form the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this2 = this;\n\n    // Increment the current write when notifying after executing\n    // a set of changes to the store.\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this2._updateSubscription(source, subscription);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this2._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    this._updatedRecordIDs = {};\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        var _rootEntry$fetchTime;\n\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = (_rootEntry$fetchTime = rootEntry.fetchTime) !== null && _rootEntry$fetchTime !== void 0 ? _rootEntry$fetchTime : Date.now();\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs);\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this3 = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this3._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4._scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  } // Returns the owner (RequestDescriptor) if the subscription was affected by the\n  // latest update, or null if it was not affected.\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasOverlappingIDs(snapshot.seenRecords, this._updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = prevInvalidationState.dataIDs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    var _this8 = this;\n\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value than\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(_this8.getSource(), snapshot.selector);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    this._optimisticSource = null;\n\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto._scheduleGC = function _scheduleGC() {\n    var _this9 = this;\n\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._hasScheduledGC) {\n      return;\n    }\n\n    this._hasScheduledGC = true;\n\n    this._gcScheduler(function () {\n      _this9.__gc();\n\n      _this9._hasScheduledGC = false;\n    });\n  };\n\n  _proto.__gc = function __gc() {\n    var _this10 = this;\n\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var references = new Set(); // Mark all records that are traversable from a root\n\n    this._roots.forEach(function (_ref7) {\n      var operation = _ref7.operation;\n      var selector = operation.root;\n      RelayReferenceMarker.mark(_this10._recordSource, selector, references, _this10._operationLoader);\n    });\n\n    if (references.size === 0) {\n      // Short-circuit if *nothing* is referenced\n      this._recordSource.clear();\n    } else {\n      // Evict any unreferenced nodes\n      var storeIDs = this._recordSource.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var dataID = storeIDs[ii];\n\n        if (!references.has(dataID)) {\n          this._recordSource.remove(dataID);\n        }\n      }\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will marc records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs[dataID] = true;\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs[dataID] = true;\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs[dataID] = true;\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availablity of a an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailablityStatus(opearionAvailability, operationLastWrittenAt, operationFetchTime) {\n  var _operationFetchTime;\n\n  var mostRecentlyInvalidatedAt = opearionAvailability.mostRecentlyInvalidatedAt,\n      status = opearionAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return status === 'missing' ? {\n    status: 'missing'\n  } : {\n    status: 'available',\n    fetchTime: (_operationFetchTime = operationFetchTime) !== null && _operationFetchTime !== void 0 ? _operationFetchTime : null\n  };\n}\n\nRelayProfiler.instrumentMethods(RelayModernStore.prototype, {\n  lookup: 'RelayModernStore.prototype.lookup',\n  notify: 'RelayModernStore.prototype.notify',\n  publish: 'RelayModernStore.prototype.publish',\n  __gc: 'RelayModernStore.prototype.__gc'\n});\nmodule.exports = RelayModernStore;"]},"metadata":{},"sourceType":"script"}